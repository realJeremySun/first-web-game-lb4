---
layout: post
title: Building an Online Game With LoopBack 4 (Part 3)
date: 2019-05-03
author: Wenbo Sun
permalink: /strongblog/building-an-online-game-with-loopback-4-pt3/
categories:
  - How-To
  - LoopBack
published: false  
---

## Part 3: Customizing APIs in Controller

### Introduction

"Ready to build amazing things?" asks the LoopBack 4 homepage before encouraging you to try the open source framework.

"Try LoopBack 4 now."

In this series, I'm going to do exactly that! Join me as I create an API web game using LoopBack 4.

The main purpose of this series is to help you learn LoopBack 4 and how to use it to easily build your own API and web project. We'll do so by creating a new project I'm working on: an online web text-based adventure game. In this game, you can create your own account to build characters, fight monsters and find treasures. You will be able to control your character to take a variety of actions: attacking enemies, casting spells, and getting loot. This game should also allow multiple players to log in and play with their friends.

### Previously on Building an Online Game With LoopBack 4

In the last episode, we used a third-party library to generate UUID and built relations between `character`, `weapon`, `aromr`, and `skill`.

Here are the previous episodes:

* [Part 1: Building a Simple LoopBack Project With MongoDB](https://strongloop.com/strongblog/building-online-game-with-loopback-4-pt1/)
* [Part 2: Generating Universally Unique ID and Managing Models Relationships](https://strongloop.com/strongblog/building-online-game-with-loopback-4-pt2/)


<!--more-->

### In this episode

We already have some simply APIs in our project. They are all default CRUD(Create, Read, Update, and Delete) APIs that auto-generated by LoopBack 4. In this episode. we will create our own APIs to achieve following functions for character updating:

![models](https://github.com/gobackhuoxing/first-web-game-lb4/blob/master/picture/models.png)
* The ability for users to equip their character with weapon, armor, and skill. This function should also be able to allow users to change weapon, armor, and skill for their character. In any cases, we should update `defence` and `attack` accordingly.
* The ability for users to unequip their character. We also need to update `defence` and `attack`.
* The ability to levelup a character when it get enough experience. We should update `currentExp`, `nextLevelExp`, `level`, `maxHealth`, `currentHealth`, `maxMana`, `currentMana`, `attack`, and `defence`.
* The ability to check character's `weapon`, `aromr`, and `skill` information.

### Create controller

First, let's create a controller for updating character. Run `lb4 controller` in your project root.

```
wenbo:firstgame wenbo$ lb4 controller
? Controller class name: UpdateCharacter
? What kind of controller would you like to generate? REST Controller with CRUD functions
? What is the name of the model to use with this CRUD repository? Character
? What is the name of your CRUD repository? CharacterRepository
? What is the type of your ID? string
? What is the base HTTP path name of the CRUD operations? /updatecharacter
   create src/controllers/update-character.controller.ts
   update src/controllers/index.ts

Controller UpdateCharacter was created in src/controllers/
```

Open `/src/controllers/update-character.controller.ts`. Add following imports. This controller is
associated with `Armor`, `Weapon`, `skill` as well.

```ts
import {Armor, Weapon, Skill} from '../models';
import {WeaponRepository, ArmorRepository, SkillRepository } from '../repositories';
```

And add following line into constructor:

```ts
constructor(
  @repository(CharacterRepository)
  public characterRepository : CharacterRepository,

  //add following lines
  @repository(WeaponRepository)
  public weaponRepository : CharacterRepository,
  @repository(ArmorRepository)
  public armorRepository : CharacterRepository,
  @repository(SkillRepository)
  public skillRepository : CharacterRepository,
) {}

```

This will connect this controller with `Armor`, `Weapon`, and `skill`. Delete all those default APIs since we don't need them anymore.


### Equip Character

The first API we need is `@patch '/updatecharacter/{id}/weapon'`. This API's job is equip character a weapon and unequip the old weapon if there is one. In this game, a character can only have one weapon.

Here is code for this API:

```ts
@patch('/updatecharacter/{id}/weapon', {
  responses: {
    '200': {
      description: 'update weapon',
      content: {'application/json': {schema: Weapon}},
    },
  },
})
async updateWeapon(
  @param.path.string('id') id: string,
  @requestBody() weapon: Weapon,
): Promise<Weapon> {
  //equip new weapon
  let char: Character = await this.characterRepository.findById(id);
  char.attack! += weapon.attack;
  char.defence! += weapon.defence;

  //unequip old weapon
  let filter: Filter = {where:{"characterId":id}};
  if((await this.weaponRepository.find(filter))[0] != undefined){
    let oldWeapon: Weapon = await this.characterRepository.weapon(id).get();
    char.attack! -= oldWeapon.attack!;
    char.defence! -= oldWeapon.defence!;
    await this.characterRepository.weapon(id).delete();
  }
  await this.characterRepository.updateById(id, char);
  return await this.characterRepository.weapon(id).create(weapon);
}
```

Let's go over it line by line.

This is the function signature. It means this API expect to get character ID from URL and weapon entity from body.

```ts
async updateWeapon(
  @param.path.string('id') id: string,
  @requestBody() weapon: Weapon,
): Promise<Weapon> {

  ...
```

Following lines will find the character entity from database. Then we will update this character's `attack` and `defence`. The `!` after `attack` and `defence` tells compiler we guarantee those variables are not undefined. Otherwise we will get a compile error. In the `weapon` model, `attack` and `defence` are both required. So we know they can not be empty.

```ts
//equip new weapon
let char: Character = await this.characterRepository.findById(id);
char.attack! += weapon.attack;
char.defence! += weapon.defence;
```

This block will check if this character already has a weapon. If so, it will update character's `attack` and `defence` and remove the old weapon from database.

```ts
//unequip old weapon
let filter: Filter = {where:{"characterId":id}};
if((await this.weaponRepository.find(filter))[0] != undefined){
  let oldWeapon: Weapon = await this.characterRepository.weapon(id).get();
  char.attack! -= oldWeapon.attack!;
  char.defence! -= oldWeapon.defence!;
  await this.characterRepository.weapon(id).delete();
}
```

Last two line will update the update character information in database and add put the new weapon into database.

```ts
await this.characterRepository.updateById(id, char);
return await this.characterRepository.weapon(id).create(weapon);
```

What we need to do for `armor` is exactly the same. But `skill` is a little bit different. Because in this game, skill will not influence `attack` and `defence`. We just need to update new skill and delete old skill.

```ts
@patch('/updatecharacter/{id}/skill', {
  responses: {
    '200': {
      description: 'update skill',
      content: {'application/json': {schema: Skill}},
    },
  },
})
async updateSkill(
  @param.path.string('id') id: string,
  @requestBody() skill: Skill,
): Promise<Skill> {
  await this.characterRepository.skill(id).delete();
  return await this.characterRepository.skill(id).create(skill);
}
```

Don't forget when we delete a character, we also need to delete it's `weapon`, `armor`, and `skill`. Open `/src/controllers/character.controller.ts`, add following lines in `del '/characters/{id}` API.

```ts
@del('/characters/{id}', {
  responses: {
    '204': {
      description: 'Character DELETE success',
    },
  },
})
async deleteById(
  @param.path.string('id') id: string
): Promise<void> {
  //delete weapon, armor, and skill
  await this.characterRepository.weapon(id).delete();
  await this.characterRepository.armor(id).delete();
  await this.characterRepository.skill(id).delete();
  ///
  await this.characterRepository.deleteById(id);
}
```

### Unequip Character

Unequip character is very easy.

For `weapon` and `armor`, simply remove them from database and update `attack` and `defence`.

```ts
@del('/updatecharacter/{id}/weapon', {
  responses: {
    '204': {
      description: 'DELETE Weapon',
    },
  },
})
async deleteWeapon(
  @param.path.string('id') id: string
): Promise<void> {
  //unequip old weapon
  let filter: Filter = {where:{"characterId":id}};
  if((await this.weaponRepository.find(filter))[0] != undefined){
    let oldWeapon: Weapon = await this.characterRepository.weapon(id).get();
    let char: Character = await this.characterRepository.findById(id);
    char.attack! -= oldWeapon.attack!;
    char.defence! -= oldWeapon.defence!;
    await this.characterRepository.weapon(id).delete();
    await this.characterRepository.updateById(id, char);
  }
}
```

For `skill`, just remove it from database.

```ts
@del('/updatecharacter/{id}/skill', {
  responses: {
    '204': {
      description: 'DELETE Skill',
    },
  },
})
async deleteSkill(
  @param.path.string('id') id: string
): Promise<void> {
    await this.characterRepository.skill(id).delete();
}
```

### LevelUp Character
When a character have enough experience, we need to levelup it. In `/src/controllers/update-character.controller.ts`:

```ts
@patch('/updatecharacter/{id}/levelup', {
  responses: {
    '200': {
      description: 'level up',
      content: {'application/json': {schema: Character}},
    },
  },
})
async levelUp(@param.path.string('id') id: string): Promise<Character> {
    let char: Character = await this.characterRepository.findById(id);
    let levels: number = 0;
    while(char.currentExp! >= char.nextLevelExp!){
      levels++;
      char.currentExp! -= char.nextLevelExp!;
      char.nextLevelExp! += 100;
    }
    char.level! += levels;
    char.maxHealth! += 10 * levels;
    char.currentHealth! = char.maxHealth!;
    char.maxMana! += 5 * levels;
    char.currentMana! = char.maxMana!;
    char.attack! += 3 * levels;
    char.defence! += levels;
    await this.characterRepository!.updateById(id, char);
    return char;
}
```

Let's go over this line by line.

If a character just beat a very strong enemy and got a lot of experience, it could levelup more than one time. So the first thing we need to do is figuring out how many times we need to levelup.

```ts
let levels: number = 0;
while(char.currentExp! >= char.nextLevelExp!){
  levels++;
  char.currentExp! -= char.nextLevelExp!;
  char.nextLevelExp! += 100;
}
```

Then we can update everyting accordingly.

```ts
char.level! += levels;
char.maxHealth! += 10 * levels;
char.currentHealth! = char.maxHealth!;
char.maxMana! += 5 * levels;
char.currentMana! = char.maxMana!;
char.attack! += 3 * levels;
char.defence! += levels;
```

Lastly, we update this character in databse.

```ts
await this.characterRepository!.updateById(id, char);
```

### Check Character information
The last function we need to achieve is the ability to check character information.

Here is the code for this API:

```ts
@get('/updatecharacter/{id}', {
  responses: {
    '200': {
      description: 'armor, weapon, and skill info',
      content: {},
    },
  },
})
async findById(
  @param.path.string('id') id: string,
): Promise<any[]> {
  let res: any[] = ['no weapon', 'no armor', 'no skill'];

  let filter: Filter = {where:{"characterId":id}};
  if((await this.weaponRepository.find(filter))[0] != undefined){
    res[0] = await this.characterRepository.weapon(id).get()
  }
  if((await this.armorRepository.find(filter))[0] != undefined){
    res[1] = await this.characterRepository.armor(id).get()
  }
  if((await this.skillRepository.find(filter))[0] != undefined){
    res[2] = await this.characterRepository.skill(id).get()
  }
  return res;
}
```

We first create a array contains three elements: 'no weapon', 'no armor', 'no skill'.
Then we will check database. For example, if this character has a weapon, we will replace `no weapon` with the weapon information. Lastly, we return the array as result.

That are all the functions we want to achieve in this episode. If you can follow all steps, you should be able to try those API at [http://[::1]:3000](http://[::1]:3000)

You can check [here](https://github.com/gobackhuoxing/first-web-game-lb4/tree/part3/firstgame) for the code of this episode.

### Applying This to Your Own Project

In this episode, we covered the how to customize APIs. You can always implement your own amazing idea in your LoopBack 4 project.

### What's Next?

In next episode, we will add user authentication and role-based access control to this project.

In the meantime, you can learn more about LoopBack in [past blogs](https://strongloop.com/strongblog/tag_LoopBack.html).
